const cp = require("child_process");
const fs = require("fs");
const path = require("path");
const rimraf = require("rimraf");
const v8Coverage = require("../../ts/dist/lib/index");

const SIMPLE_MAIN_RE = /^main\.\d+\.js$/;
const MAIN_RE = /^main\.(.+)\.js$/;
const MAIN_ALL = 'main.all.js';
const ROOT = path.join(__dirname, "..", "..");
const PROGRAMS_DIR = path.join(ROOT, "test-data", "programs");

/**
 * Generates fixtures
 *
 * Each fixture is a directory with a `lib.js` file and a few `main.X.js`
 * files where `X` is an integer.
 * For each main file, it will generate a `cov.X.json` file containing coverage
 * for `lib.mjs` when using the corresponding main as the entry point.
 * It also generates a `cov.all.json` obtained by executing (importing) all
 * the entry points.
 *
 * Merging all the `cov.X.json` coverages should result in `cov.all.json`.
 */
async function main() {
  const fixtures = await getFixtures();
  for (const name of fixtures) {
    await generateFixture(name);
  }
}

async function getFixtures() {
  const children = await fs.promises.readdir(PROGRAMS_DIR);
  return children.filter((child) => fs.statSync(path.join(PROGRAMS_DIR, child)).isDirectory());
}

async function generateFixture(name) {
  const dir = path.join(PROGRAMS_DIR, name);
  const simpleMains = getSimpleMains(dir);
  const mainAll = generateMainAll(simpleMains);
  await fs.promises.writeFile(path.join(dir, MAIN_ALL), mainAll);
  const trees = [];
  for (const simpleMain of [...simpleMains, MAIN_ALL]) {
    const id = MAIN_RE.exec(simpleMain)[1];
    const libCoverage = await getLibCoverage(dir, simpleMain);
    await fs.promises.writeFile(path.join(dir, `cov.${id}.json`), JSON.stringify(libCoverage, null, 2));
    const libFn = getLibFunction(libCoverage);
    trees.push(v8Coverage.RangeTree.fromSortedRanges(libFn.ranges));
  }
  const asciiForestLines = v8Coverage.emitForestLines(trees);
  const merged = asciiForestLines.pop();
  const header = asciiForestLines.shift();
  const asciiRanges = `${header}\n${asciiForestLines.join("\n+\n")}\n=\n${merged}\n`;
  await fs.promises.writeFile(path.join(dir, "ranges.txt"), asciiRanges);
}

function getSimpleMains(dir) {
  return fs.readdirSync(dir)
    .filter((child) => SIMPLE_MAIN_RE.test(child))
    .sort((a, b) => {
      a = parseInt(MAIN_RE.exec(a)[1]);
      b = parseInt(MAIN_RE.exec(b)[1]);
      return a - b
    })
}

function generateMainAll(mains) {
  return [
    '// DO NOT EDIT: generated by `generate-fixtures.js`',
    'const lib = require.resolve(\'./lib.js\')',
    'function main () {',
    ...mains.map(main => `  require(${JSON.stringify(`./${main}`)})\n  delete require.cache[lib]`),
    '}',
    'main()',
    '',
  ].join('\n')
}

async function getLibCoverage(dir, main) {
  const covDirName = `cov-${main}`;
  const covDir = path.join(dir, covDirName);
  await rmDir(covDir);
  await spawnWithCoverage(dir, main, covDir);
  const processCov = await getProcessCov(covDir);
  await rmDir(covDir);
  const libUrl = path.join(dir, "lib.js");
  for (const scriptCov of processCov.result) {
    if (scriptCov.url === libUrl) {
      return {
        scriptId: '1',
        url: '/lib.js',
        functions: scriptCov.functions
      }
    }
  }
  throw new Error(`Coverage not found for \`lib.js\` for ${path.join(dir, main)}`)
}

function getLibFunction(coverage) {
  for (const fn of coverage.functions) {
    if (fn.functionName === 'lib') {
      return fn
    }
  }
  throw new Error(`Lib function not found for ${path.join(coverage.url)}`)
}

async function spawnWithCoverage(dir, main, covDir) {
  return new Promise((resolve, reject) => {
    const proc = cp.spawn(
      process.execPath,
      [main],
      {
        cwd: dir,
        env: {NODE_V8_COVERAGE: covDir},
      },
    );
    proc.once('close', (code, signal) => {
      if (code === 0) {
        resolve()
      } else {
        reject(new Error(`Non-zero return code for: ${path.join(dir, main)}`))
      }
    })
  })
}

async function rmDir(dir) {
  return new Promise((resolve, reject) => {
    rimraf(dir, (err) => {
      if (err !== null) {
        reject(err)
      } else {
        resolve()
      }
    })
  })
}

async function getProcessCov(covDir) {
  const covChildren = await fs.promises.readdir(covDir);
  if (covChildren.length !== 1) {
    throw new Error(`Expected a single file in: ${covDir}`)
  }
  return JSON.parse(await fs.promises.readFile(path.join(covDir, covChildren[0]), {encoding: 'UTF-8'}));
}

main();
